# चर और परिवर्तनशीलता

<!-- This substitution trick loses tense information. E.g. the translator does not know whether _ERROR_/_ERRORS_ is singular or plural -->

जैसा कि अध्याय 2 में बताया गया है, डिफ़ॉल्ट रूप से चर अपरिवर्तनशील हैं। यह कई संकेतों में से एक है रस्ट जो आपको अपना कोङ इस तरह से लिखने के लिए देता है, जो रस्ट के सुरक्षा और आसान सहवर्तीता के सुविधाओं का उपयोग कर सके। हालाँकि, आपके पास अभी भी अपना चर परिवर्तनशील बनाने का विकल्प है। आइए देखें कि कैसे और क्यों रस्ट आपको अपरिवर्तनशीलता के पक्ष में प्रोत्साहित करता है और क्यों कभी-कभी आप यह ना करना चाहेंगे।

जब एक चर अपरिवर्तनशील होता है, तो एक बार जानकारी एक नाम से बंध जाए, तो आप उस जानकारी को नहीं बदल सकते। इसे समझने के लिए, अपनी *projects* फ़ोल्ङर में `cargo new variables` का उपयोग करके *variables* नामक एक नई प्रोग्राम उत्पन्न करें।

फिर, अपने नए *variables* फ़ोल्ङर में, *src/main.rs* खोलें और मौजूदा कोङ को निम्नलिखित कोङ से बदलें। यह अभी कंपाइल नहीं होगा:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

सेव करें और `cargo run` का उपयोग करके प्रोग्राम चलाएं। आपको एरर संदेश प्राप्त होना चाहिए, जैसा कि इस आउटपुट में दिखाया गया है:

```text
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

यह उदाहरण दिखाता है कि कैसे कंपाइलर आपके प्रोग्राम में एरर को खोजने में आपकी सहायता करता है। भले ही कंपाइलर एरर निराशाजनक हो सकता है, उनका मतलब केवल यह है कि आपका प्रोग्राम अभी सुरक्षित रूप से वह नहीं कर रहा है जो आप करवाना चाहते हैं; इसका मतल यह *नही* है, कि आप एक अच्छे प्रोग्रामर नही हैं! अनुभवी रस्ट के उपयोगिता को अभी भी कंपाइलर एरर मिलते है।

एरर संकेत करता है कि एरर का कारण है कि आप `cannot assign twice
to immutable variable x`, क्योंकि आपने अपरिवर्तनशील `x` चर को दूसरा जानकारी असाइन करने का प्रयास किया है।

यह महत्वपूर्ण है कि हम कंपाइल-क्षण एरेर प्राप्त करें, जब हम एक जानकारी को बदलने का प्रयास करते हैं, जिसे हमने पहले अपरिवर्तनशील के रूप में निर्दिष्ट किया था, क्योंकि यह बहुत समय बग को जन्म दे सकता है। अगर हमारा कोङ का एक हिस्सा इस धारणा पर चल रहा है कि एक जानकारी कभी नहीं बदलेगा और हमारे कोङ का एक और हिस्सा उस जानकारी को बदल देगा, तो संभव है कि कोङ का पहला भाग वह ना करे जो उसे करना चाहिये। इस तरह के बग के कारण को बाद मे खोजना करना मुश्किल हो सकता है, खासकर जब कोङ का दूसरा टुकड़ा जानकारी को केवल *कभी-कभी* बदलता है।

रस्ट में, कंपाइलर इस बात की गारंटी देता है कि जब आप बताते हैं कि जानकारी को परिवर्तित नहीं होना चाहिये, तो यह वास्तव में परिवर्तित नहीं होगा। इसका मतलब यह है कि जब आप कोङ पढ़ और लिख रहे होते हैं, तो आपको इस बात का ध्यान नहीं रखना होगा कि कैसे और कहां जानकारी बदल सकते हैं। इस प्रकार आपके कोङ का तर्क करना आसान है।

लेकिन परिवर्तनशीलता बहुत उपयोगी हो सकता है। चर केवल डिफ़ॉल्ट रूप से अपरिवर्तनशील हैं; जैसा कि आपने अध्याय 2 में किया था, आप चर के सामने `mut` जोड़कर उन्हें परिवर्तनशील बना सकते हैं। इस जानकारी को बदलने की अनुमति देने के अलावा, `mut` कोङ के भविष्य के पाठकों को यह संकेत देता है कि कोङ के अन्य हिस्से इस चर के जानकारी को बदल देंगे।

उदाहरण के लिए, *src/main.rs* को निम्नलिखित कोङ से बदलें:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

जब हम प्रोग्राम चलाते हैं, तो हमें यह मिलता है:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

जब हमने `mut` का उपयोग किया, तो हमने हमे `x` को `5` से `6` तक बाइंड करने की अनुमति दी है। कुछ मामलों में, आप एक चर परिवर्तनशील बनाना चाहते हैं, क्योंकि यह कोङ लिखना अधिक सुविधाजनक बनाता है, की अगर इसमें केवल अपरिवर्तनशील चर का उप्योग था।

बग की रोकथाम के अलावा, विचार करने के लिए कई समझौतायें हैं। उदाहरण के लिए, ऐसे मामलों में जहां आप बड़ी डेटा संरचनाओं का उपयोग कर रहे हैं, स्थान में इंस्टेंस को बदलना, नए आवंटित इंस्टेंस की प्रतिलिपि बनाने और फ़ंक्शन से वापस करने से अधिक तेज़ हो सकता है। छोटी डेटा संरचनाओं के साथ, नया इंस्टेंस बनाने और अधिक फ़ंक्शनल प्रोग्रामिंग शैली में लिखने के माध्यम से सोचने में आसान हो सकता है, इसलिए उस स्पष्टता को प्राप्त करने के लिए कम रफ़्तार एक सार्थक जुर्माना हो सकता है।

### चर और स्थिरांक के बीच अंतर

चर के जानकारी को बदलने में असमर्थ होने के कारण आपको एक और प्रोग्रामिंग अवधारणा याद आ सकती है, जिसमें अधिकांश अन्य भाषाओं में: *स्थिरांक* हैं। अपरिवर्तनशील चर की तरह, स्थिरांक जानकारी हैं जो एक नाम से बंधे हैं और उन्हें बदलने की अनुमति नहीं है, लेकिन स्थिरांक और अपरिवर्तनशील चर के बीच कुछ अंतर हैं।


सबसे पहले, आपको स्थिरांक के साथ `mut` का उपयोग करने की अनुमति नहीं है। स्थिरांक केवल डिफ़ॉल्ट रूप से अपरिवर्तनशील नहीं होते हैं - वे हमेशा अपरिवर्तनशील होते हैं।

आप `let` कीवर्ड के बजाय `const` कीवर्ड का उपयोग करके स्थिरांक घोषित करते हैं, और जानकारी का प्रकार एनोटेट *होना ही चाहिए*। हम अगले खंड "डेटा टाइप" मे, में चर के प्रकार और एनोटेशन की चरचा करने वाले हैं, इसलिए अभी विवरण के बारे में चिंता न करें। बस जान लें कि आपको हमेशा टाइप को एनोटेट करना चाहिए।

ग्लोबल स्कोप सहित किसी भी दायरे में स्थिरांक घोषित किए जा सकते हैं, जो उन्हें ऐसे जानकारी के लिए उपयोगी बनाता है, जिसके बारे में कोङ के कई हिस्सों को जानना आवश्यक है।

अंतिम अंतर यह है कि स्थिरांक केवल एक स्थिर एक्सप्रेशन के साथ सेट किया जा सकता है, न कि फ़ंक्शन कॉल या किसी अन्य जानकारी के परिणाम पर, जिसकी केवल रनटाइम पर गणना की जा सकती है।

यहां एक निरंतर घोषणा का एक उदाहरण है, जहां निरंतरता का नाम `MAX_POINTS` है और इसका जानकारी 100,000 पर सेट है। (रस्ट का निरंतरों नामकरण का सम्मेलन है की शब्दों के बीच अंडरस्कोर (\_) हो, और सभी अक्षर अपरकेस मे हों, और पठनीयता में सुधार करने के लिए अंकों के बीच भी अंडरस्कोर डाला जा सकता है):

```rust
const MAX_POINTS: u32 = 100_000;
```

स्थिरांक, जिस स्कोप मे घोशित किये गए हों, उसमे प्रोग्राम के पुरे जीवन के लिये मन्य है। यह उन्हें आपके एप्लिकेशन डोमेन में उन मूल्यों के लिए एक उपयोगी विकल्प बनाता है जिनके बारे में प्रोग्राम के कई हिस्सों को जानने की आवश्यकता हो सकती है, जैसे कि किसी गेम के किसी भी खिलाड़ी को अधिकतम कितने अंक मिल सकते हैं, या प्रकाश की गति की अनुमति।

हार्डकोङिङ जानकारी का नामकरण प्रोग्राम में किया जाता है क्योंकि स्थिरांक कोङ के भावी अनुरक्षकों को उस जानकारी का अर्थ बताने में उपयोगी है। यह आपके कोङ में केवल एक ही स्थान रखने में मदद करता है, यदि आपको भविष्य में उस जानकारि को बदलने की आवश्यकता हो।

### चर ग्रहण

जैसा कि आपने अध्याय 2 में "गुप्त संख्या की तुलना करें" अनुभाग में देखा, आप एक नए चर को पिछले चर के समान नाम से घोशित कर सकते हैं, जिस्से नया चर पुराने चर हो ग्रहण कर देता है। रस्ट के उपयोगिता का कहना है कि पहला चर दूसरे द्वारा *ग्रहण* है, जिसका अर्थ है कि है जब चर का उपयोग किया जाए, तो दूसरा चर का जानकारी उपयोग होगा। हम उसी चर के नाम का उपयोग करके और इस तरह से `let` कीवर्ड के उपयोग को दोहराकर एक चर को ग्रहणित कर सकते हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

यह प्रोग्राम पहले `x` को `5` के जानकारी से बाँधता है। फिर यह `x` को `let x =` दोहराकर, मूल जानकारी को `1` से जोड़ देता है, इसलिए `x` का जानकारि तब `6` है। तीसरा `let` भी `x` को ग्रहण देता है, और पिछले जानकारी को `2` से गुणा करके `x` को `12` का अंतिम जानकारी देता है। जब हम यह प्रोग्राम चलाते हैं, तो निम्नलिखित आउटपुट मिलेगा:

```text
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

शैडोइंग एक चर को `mut` के रूप में चिह्नित करने से अलग है, क्योंकि हमें कंपाइल-क्षण एरर मिलेगा, यदि हम गलती से `let` कीवर्ड का उपयोग किए बिना इस चर को पुन: असाइन करने का प्रयास करते हैं। `let` का उपयोग करके, हम एक जानकारी पर कुछ परिवर्तन कर सकते हैं, लेकिन उन परिवर्तनों के पूरा होने के बाद चर को अपरिवर्तनशील कर सकते हैं।

`mut` और ग्रहण के बीच दूसरा अंतर यह है कि, क्योंकि हम प्रभावी रूप से एक नया चर बना रहे हैं जब हम फिर से `let` कीवर्ड का उपयोग करते हैं, तो हम जानकारी के टाइप को बदल सकते हैं, और वही नाम का उपयोग कर सकते हैं। उदाहरण के लिए, मान लें कि हमारा प्रोग्राम किसी उपयोगकर्ता को यह बताने के लिए कहता है कि वे 'स्पेस' (space) अक्षर का इनपुट करके शबदों के बीच कितने रिक्त स्थान चाहते हैं, लेकिन हम वास्तव में उस इनपुट को संख्या के रूप में रखना करना चाहते हैं:

```rust
let spaces = "   ";
let spaces = spaces.len();
```

इस निर्माण की अनुमति है क्योंकि पहला `spaces` चर एक स्ट्रिंग टाइप का है और दूसरा `spaces` चर, जो कि एक नया चर है, और वही नाम का उपयोग करता है, एक संख्या टाइप का चर है। इस प्रकार ग्रहण हमें अलग-अलग नामों के खोजने से मुक्त करता है, जैसे कि `spaces_str` और `spaces_num`; इसके बजाय, हम सरल `spaces` नाम का पुन: उपयोग कर सकते हैं। हालाँकि, यदि हम इसके लिए `mut` का उपयोग करने का प्रयास करते हैं, जैसा कि यहाँ दिखाया गया है, तो हमें कंपाइल-क्षण एरर मिलेगा:

```rust,ignore
let mut spaces = "   ";
spaces = spaces.len();
```

एरर का कहना है कि हमें एक चर का प्रकार बदलने की अनुमति नहीं है:

```text
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```



अब जब हमने पता लगाया है कि चर कैसे काम करते है, चलो देखते हैं कि उनके और क्या क्या टाइप हो सकते हैं।
