## फ़ंक्शन

रस्ट कोड मे फंक्शन हर जगह मिलते हें। आपने सबसे महत्वपूर्ण फंक्शन मे से एक देख चुके हैं: `main` फंक्शन, जहां से कई प्रोगराम आरंभ होते है। आपने `fn` कीवर्ड भी देखा है, जो आपको नए फंक्शन डीक्लैर करने देता है।

रस्ट मे परंपरा है कि हम *स्नेक केस (snake case)* का प्रयोग करते हैं। इसमे सारे अक्षर लोअरकेस (lowercase) होते हैं, और श्बदों को अंडरस्कोर (underscore) यानी `_` से अलग किया जाता है। निम्लिखित प्रोगराम मे एक फंक्शन डेफ़ीनीशन का डेफीनीषण (definition) (यानी परिभाषा) उदाहरण है।

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");

    another_function();
}

fn another_function() {
    println!("Another function.");
}
```

रस्ट मे फंक्शन डेफीनीषण का आरंभ `fn` से होता है, और उसके आगे `()` होते हैं। उसके आगे वाले `{}` कंपाईलर को यह बताते हैं कि फंक्शन कहां शुरू ाुर कहां खतम होता है।

फंक्शन को बुलाने के लिए हम उसके नाम के आगे `()` लगाते हैं। क्योंकी `another_function` को परोगराम मे डीफाईन किया गया है, उसे `main` फंक्शन के अंदर से बुलाया जा सकता है। धयान कीजिए कि `another_function` को `main` फंक्शन के बाद लिखा है; हम पहले भी लिख सकते थे. रस्ट को इससे मतलब नही की आपने फंक्शन कहां डीफाईन किया है, बस इतना कि कहीं किया हो।

चलो *functions* नामक एक नया बाइनरी परौजेक्ट शुरू करते हैं। `another_function` वले उदाहरण को *src/main.rs* मे डालकर चलाएं। आपको यह दिखना चाहिए:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
```

वाक्य उसी क्रम मे चलते हैं जिस क्रम मे वह `main` फंक्शन मे दिखते हैं। अर्थार्थ, पहले "Hello, world!" संदेश प्रिंट होता हाि, और फिर `another_function` को बुलाया जाता है, और उसका संदेश "Another function." प्रिंट होता है।

### फंक्शन पैरामीटर

फंक्शन को *पैरामीटर (parameter)* के साथ भी डिफाइन किया जा सकता है। पैरामीटर ऐसे खास चर होते हैं जो फंक्शन के हसताक्षर के एक हिस्सा होते हैं। जब फंक्शन मे पैरामीटर होते हैं, नब आप उनमे जानकारी भर सकते हैं। तकनीकी रूप से पैरामीटर मे भरे जानकारी को *आर्जयूमेंट (argument)* कहते हैं, लेकिन साधाहरण भाषा मे लोग दोनो शब्द उप्योग करते हैं।

निम्नलिखित कोड पैरामीटर का उदाहरण देता है:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!("The value of x is: {}", x);
}
```

इस प्रोग्राम को चलाने पर आपको यह दिखना चाहिए:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
```

`another_function` के डेफीनीशण मे `x` नामक एक पैरामीटर है। उसका टाईप `i32` दिया गया है। जब `another_function` को जानकारी के रूप मे `5` दिया जाता है, तो `println!` मैक्रो (macro) `{}` की जगह `5` डाल देता है।

फंक्शन के हस्ताक्षर मे हर पैरामीटर का टाईप बताना ज़रूरी है। रस्ट मे यह निर्णय जानबूजकर लिया गया है। क्योंकी फंक्शन मे ही हर पैरामिटर का टाईप लखा है, कंपाईलर को टाईप जानने के लिए और कहीं देखने की ज़रूरत नही, और फंक्शन बुलाते समय आपको टाइप बताने कि जरूरत नही।

अगर आप डाहते हैं कि फंक्शन मे अनेक पैरामीटर हों, तो उनहें "," से अलग करें। उदाहरण के लिए:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!("The value of x is: {}", x);
    println!("The value of y is: {}", y);
}
```

इस उदाहरण के फंक्शन मे दो पैरामीटर हैं, और दोनो के टाईप `i32` है। फंक्शन दोनो के जानकारी को प्रिंट कर देता है। ध्यान कीजिए कि सारे पैरामीटर का टाईप एक ही हो, ऐसा जरूरी नही है। यह सिर्फ एक उदाहरण है।

इस उदाहरण को चलाने के लिए, अपने *functions* प्रोग्राम के *src/main.rs* फाइल मे ऊपर लिखे कोड लीख दें (और पुराना कोच हटा दें), और `cargo run` का उप्योग कर चला दें:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```

क्योंकी हमने फंक्शन को बुलाते वकत `x` को `5` और `y` को `6` की जानकारी दी थी, वह इन दो अंकों के साथ दो वाक्य प्रिंट करता है।

### function बांडी (यानी सरीर)

फंक्शन बांडी सटेटमेंट से बने होते हें। वह वैकलपिक रूप से expression से खतम हो सकते हैं। अब तक हमने सिर्फ एसे function देखे हैं जो expression से खतम नही होते, लेकिन आपने expression को statement के हिससे के के रूप मे देखा है। कयुकी रस्ट expression को मुख्य रूप से उपयोग करता है, expression और statement मे अंतर समझना जरूरी है। हर भाषा मे यह अंतर नही होता, तो चलिए इसे function मे expression की भूमिका समझते हैं।

### statement और expression

हमने statement और expression पहले ही इसतेमाल किया है। *statement* computer को आदेष देते हैं कुछ काम करने के लिये, लेकिन वह कोई जानकारी वापिस नही करते। *expression* जानकारी वापिस देते हैं। चलिए थोडे उसाहरण देखते हैं।

किसि चर को बनाकर उसमे `let` कीवर्ड के ज़रिए कोई जानकारी भरना एक statement है। निम्नलिखित उदाहरण मे `let y = 6;` एक स्टेटमेंट है:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let y = 6;
}
```

<span class="caption">Listing 3-1: A `main` function declaration containing one statement</span>

function definition भी statement होते हैं; ऊपर का पूरा उदाहरण खुद से एक statement है।

statement जानकारी वापिस नही देते। इसलिए आप उन्हें `let` statement द्वारा किसि चर मे जानकारी नही भर सकते, जैसे निम्नलिखित कोड करने कि कोशिश कर रहा है; आपको एक एरर मिलेगा:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
fn main() {
    let x = (let y = 6);
}
```

जब आप प्रोग्राम चलाएंगे तो आपको ऐसा एरर मिलेगा:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
```

`Let y = 6` स्टेटमेंट कोई जानकारी वापस नहीं करता है, इसलिए `x` मे बांधने के लिए कुछ भी नही है। यह अन्य भाषाओं में होने वाली घटनाओं से अलग है, जैसे कि C और Ruby, जहां असाइनमेंट (यानी `=` से संकेत होने वाला काम) असाइनमेंट का जानकारी लौटाता है। उन भाषाओं मे, आप `x = y = 6` लिख सकते हैं और दोनों` x` और `y` मे `6` भर जाएगा; रस्ट में ऐसा नहीं है।

एक्सप्रेशन किसी जानकारी मे बदलते हैं, और रस्ट का दूसरा महत्वपूर्ण हिस्सा हैं। गणित के भाग, जैसे `5 + 6` एक एक्सप्रेशन है जो `11` का रूप लेता है। एक्सप्रेशन किसी सटेटमेंट का हिस्सा बन सकता है: Listing 3-1 मे, `let y = 6` सटेटमेंट मे `6` एक एक्सप्रेशन है। फंक्षन को बुलाना एक एक्सप्रेशन है। मैकरो को बुलाना भी एक एक्सप्रेशन है। जब हम `{}` का प्रयोग कर कोड का बलांक (block) लिखते हैं, वह भी एक एक्सप्रेशन है, उदाहरण के लिये:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {}", y);
}
```

मे यह एक्सप्रेशन:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

एक block है,, जो यहां, `4` मे evaluate होता है। यह जानकारी `y` मे बंध जाता है, जो `let` सटेटमेंट का एक हिस्सा है। धयान कीजिए `x + 1` वाक्य के अंत मे `;` नही है, जो आपके देखे गए अधिकतर वक्यों से अलग है। एक्सप्रेशनों का अंत `;` से नही होता। अगर आप एक्सप्रेशन के अंत मे `;` डालें, तो वह सटेटमेंट बन जाता है। सटेटमेंट कोइ जानकारी वापिस नही करते। इस बात को ध्यान रखते हुए आगे जानकारी वापिस करने वाले फंकशन के बारे मे पढें।

### जानकारी वापिस करने वाले फंकशन

जिस कोड ने फंकशन को बुलाया, उस कोढ को फंकशन जानकारी वापिस कर सकते हैं। हम वापिस होने वाले जानकारी को नाम तो नही देते, लेकिन  उसके टइाप को ज़रुर डिक्लैर करते हैं, `->` के द्वारा। रस्ट मे, फ़ंकशन से वापिस की गई जानकारी और उसे बुलाने वाले एक्सप्रेशन की जानकारी, एक ही है। अप फ़ंकशन के अंत से पहले ही, `return` और उस्से संबंधित जानकारी, के सहित, फ़ंकशन से वापिस आ सकते हैं। लेकिन ज्यादातर फ़ंकशन अपना आखरी एक्सप्रेशन का जानकारी अपने आप वापिस कर देते है। नीचे उदाहरण है एक फ़ंकशन का जो जानकारी वापिस करता है:

<span class="filename">Filename: src/main.rs</span>

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is: {}", x);
}
```

`five` फंकशन मे कोई फ़ंक्शन का बुलावा, कोइ मैक्रो का बुलावा, या `let` सटेटमेंट नही है। इसमे संख्या `5` बस अपने आप मे है। रस्ट मे इसे सही फ़ंकशन माना जाता है। ध्यान कीजिए कि यहां वापिस होने वाले जानकारी कि टाईप `-> i32` के द्वारा बताया गया है। इस कोड को चलाएं; निम्नलिखित आटपुट मिलना चाहिए:

```text
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
```

`five` फ़ंक्शन से वापिस होने वाली जानकारी `5` है, जिस वजह से जानकारी की टाइप `i32` है। चलो इसे गौर से देखें। दो मुख्य बाते हैं: पहले `let x = five();` हमे बताता है कि हम वापिस किए गए जानकारी को एक चर (`x`) के प्रथम जानकारी मे भरने के लिए प्रयोग कर रहे हैं। क्योंकी फंक्शन `five` `5` वापिस करता है, यह वाक्य का अर्थ यह है:

```rust
let x = 5;
```

दूसरी बात, `five` फ़ंक्शन मे कोइ पैरामीटर नही है, और वह वापिस होने वाली टाइप को अलग से बताता है। फ़ंक्शन का कोड सिर्फ़ एक `5` है बिना किसी `;` के क्योंकी वह एक एक्सप्रेशन है जिसकी जानकारी हम वापिस करना चाहते हैं।

चलो एक और उदाहरण देखते हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1
}
```

चलाने पर, यह `The value of x is: 6` आउटपुट देता है। लेकिन अगर हम `x + 1` के अंत पर एक `;` लिख दें, तो वह एक्सप्रेशन से सटेटमेंट बन जाता है। यहां हमे एरर मिलता है।

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
fn main() {
    let x = plus_one(5);

    println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
    x + 1;
}
```

को कंपाइल करने पर यह एरर मिलेगा:

```text
error[E0308]: mismatched types
 --> src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -> i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
```

मुख्य एरर “mismatched types” कोड की सबसे बडी गलती बताता है। फ़ंकशन `plus_one` का डेफिनीशण कहता है कि फ़ंक्शन
`i32` वापिस करेगा, लेकिन सटेटमेंट जानकारी मे नही बदलते (जिसे `()` से दिखाया जाता है), इसलिए कोइ जानकारी वापिस नही होती, जो फ़ंक्शन डेफ़िनीशन से नही मिलती। इसका नतीजा एरर है। आउटपुट मे, रस्ट एरर का एक विकल्प भी बताता है (ध्यान रखें, रस्ट के बताए गए विकल्प सिर्फ सुझाव हैं। वह हमेशा सही विक्लप नही होते): सुझाव है कि `;` हटा दें, जिससे एरर चला जाएगा।
