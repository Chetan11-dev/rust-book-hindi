## `Cargo` का उप्योग

Cargo रस्ट का "बिल्ङ सिस्टम" (build system) और "पैकेज मैनेजर" (package manager)
है। ज़्यादातर लोग अपने रस्ट कोङ को संभालने के लिये इस साधन का उप्योग करते हैं
क्योंकी यह आप के लिये कैइ काम कर देता है। उधाहरण से, कोङ को "बिल्ङ"
(build)/"कंपाइल" (compile) करना, उन "लाईब्ररीयों" (library) को ङाउनलोङ कर्ना
जिनपे आप्का कोङ निर्भर है, और फिर उन लाईब्ररीयों को बिल्ङ करना। (जिन लाइब्ररीयों
पे आप्का कोङ निर्भर है, उनहे हम "ङिपेंङेंसी" (dependency) कहते हैं।)

सरल रस्ट प्रोग्राम, जैसे की हमने अभी तक लिखे हैं, मे कोई ङिपेंङेंसी नही होते।
इस्लिये, अगर हम अभी `Cargo` के साथ हमारा "Hello, world!" प्रोग्राम बनायें, तो वह
`Cargo` का वही हिस्सा उप्योग करेगा जो रस्ट कोङ को बिल्ङ/कंपाइल कर्ता है। जब आप
और बङे और जटिल प्रोग्राम लिखेंगे, आप को ङिपेंङेंसीयों का प्रयोग करना पधेगा। उस
समय, अगर आप रस्ट कोङ को `Cargo` के साथ बनायें, तो यह काम बहुत सरल होगा।

ज़्यादातर रस्ट कोङ `Cargo` का उप्योग कर्ता हैं, इस्लिये हम इस किताब मे भी यही
मनेंगे की आप भी रस्ट का उप्योग कर रहे हैं। `Cargo` रस्ट के साथ आता है, अगर आपने
रस्ट को ऐसे ही इंस्टाल किया है जैसे हमने इस किताब मे बताय है, तो आप के कंप्यूटर
मे `Cargo` पहले से ही होग। अगर आपने किसी और तरीके से इंस्टाल किया है, तो `Cargo`
है या नही देखने के लिये अपने टर्मिनल मे निम्नलिखित वक्य लिखें:

<!-- Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the “Installation” section. If you
installed Rust through some other means, check whether Cargo is installed by
entering the following into your terminal: -->

```text
$ cargo --version
```

अगर आप्को एक संस्करण अंक दिखे, तो आप्के पास `Cargo` है, बधाइ हो! अगर आपको एरर
दिखे, जैसे की `command not found`, तो क्रिपया आपके इंस्टालेशन तरीके के प्रलेखन
को पङें, और `Cargo` को अलग से इंस्टाल कैसे करते है, यह देख लें।

<!-- If you see a version number, you have it! If you see an error, such as `command
not found`, look at the documentation for your method of installation to
determine how to install Cargo separately. -->

<!-- ### Creating a Project with Cargo -->
### `Cargo` का उप्योग कर कोङ लिखना चालू करना

चलो `Cargo` का उप्योग करके रस्ट का एक नया प्रोग्राम लिखते हैं, और देखते हैं की
यह प्रक्रिया आपके पहले वाले `Hello, world!` प्रोग्राम से कैसे अलग है। टर्मिनल मे
अपने *projects* "फ़ोल्ङर" (folder) (या आपने जहां भी अपने प्रोग्रामों को जहां भी
लिखना चाहते हैं). फिर, निम्न्लिखित वक्य/आदेश चलायें:

<!-- Let’s create a new project using Cargo and look at how it differs from our
original Hello, world! project. Navigate back to your *projects* directory (or
wherever you decided to store your code). Then, on any operating system, run
the following: -->

```text
$ cargo new hello_cargo
$ cd hello_cargo
```

पहला आदेश *hello_cargo* नमक एक नया फ़ोल्ङर बनाता है। हमने अपने प्रोग्राम को
*hello_cargo* नाम दिया है, और `Cargo` उसी नाम के एक फ़ोल्ङर मे अपने फ़ाईल बनाता
है।

<!-- The first command creates a new directory called *hello_cargo*. We’ve named
our project *hello_cargo*, and Cargo creates its files in a directory of the
same name. -->

एक बार *hello_cargo* फ़ोल्ङर जाकर एक बार क्या-क्या फ़ाईल हैं, यह देखें। आपको
दिखेगा कि `Cargo` ने हमारे लिये दो फ़ाईल और एक फ़ोल्ङर बनाये हैं: एक
*Cargo.toml* फ़ाईल और एक *src* फ़ोल्ङर जिसके अंदर एक *main.rs* फ़ाईल है। उसने एक
नया `Git` का कोष भी बनाया है, जिसमे एक *.gitignore* फ़ाइल भी है।

<!-- Go into the *hello_cargo* directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a *Cargo.toml* file and a
*src* directory with a *main.rs* file inside. It has also initialized a new Git
repository along with a *.gitignore* file. -->

> ध्यान दें: `Git` एक प्रचलित "वर्ज़न कंट्रोल सिस्टम" (version control system)
> है। वह एक ऐस प्रणली है, जिसे लोग अपने प्रोग्रामों को लिखते समय उसके अलग-अलग
> संस्करणों को संभालने के लिये प्रयोग करते हैं। आप `Git` को छोङ कर किसी और
> सिस्टम का प्रयोग करना चाहते हैं, तो आप `cargo new` आदेश को बदल सकते हैं
> `--vcs` "फ़्लैग" (flag) के साथ। आप उपलब्ध विकल्पों का जंच `cargo new --help`
> के साथ कर सकते हैं।

<!-- > Note: Git is a common version control system. You can change `cargo new` to
> use a different version control system or no version control system by using
> the `--vcs` flag. Run `cargo new --help` to see the available options. -->

आप अपने पसंदिता "तेक्स्ट एङिटर" (text editor) के साथ *Cargo.toml* खोलें, तो आपको वो निम्न्लिखित जैसा दिखेगा.

<!-- Open *Cargo.toml* in your text editor of choice. It should look similar to the
code in Listing 1-2. -->

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]

[dependencies]
```

<span class="caption">Listing 1-2: `cargo new` के द्वारा बनाया गया *Cargo.toml*  फ़ाईल</span>

<!-- <span class="caption">Listing 1-2: Contents of *Cargo.toml* generated by `cargo
new`</span> -->

यह फ़ाईल [*TOML*][toml]<!-- ignore --> फ़ंर्मैट (विशय को लिखने का तरीका) मे लिखा गाया है, जो `Cargo` इस्तेमाल करता है। हम अब इस फ़ंर्मैट

<!-- This file is in the [*TOML*][toml] <!-- ignore - -> (*Tom’s Obvious, Minimal
Language*) format, which is Cargo’s configuration format. -->

[toml]: https://github.com/toml-lang/toml

पहला वक्य है, `[package]`, जो सूचित करता है कि निम्नलिखित भाग एक "पैकेज"
(package) को "कॉन्फ़िगर" (configure) कर रहा है (अर्थार्त, वह इस पैकेज के बारे मे
कुछ जानकारी देता है, जो कि इसे बनाने मे काम अयेंगी). जैसे जैसे हम इस फ़ाईल मे और
जानकारी दालेंगे, हम और भाग जोङेंगे।

<!-- The first line, `[package]`, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections. -->

अगले तीन वाक्य आपके प्रोग्राम को कंपाइल करने के लिये जरूरी जानकारी `Cargo` को
देते हैं: नाम, संख्य और लेखक. `Cargo` को आपके नाम और ईमेल (email) की जानकारी
आपके "एन्वाइरन्मेंट" (environment) (कंप्युटर से दी गइ जानकारी) से मिल्ती है, अगर
यह जानकारी गलत है, तो आप अभी इसे ठीक करके फ़ाइल मे सेव कर सकते हैं।

<!-- The next three lines set the configuration information Cargo needs to compile
your program: the name, the version, and who wrote it. Cargo gets your name and
email information from your environment, so if that information is not correct,
fix the information now and then save the file. -->

अंतिम वाक्य, `[dependencies]`, अगले भाग को शुरू करता है, जहां आप अपने प्रोग्राम
के ङिपेंङेंसी लिख सकते हैं। रस्ट मे कोङ के पैकेज को "क्रेट" (crate) कहते हैं। इस
प्रोग्राम के लिये हमे और कोइ क्रेट कि ज़रूरत नही है, पर अध्याय २ के पहले
प्रोग्राम मे उन्की ज़रूरत पधेगी, और हम तब देखेंगे कि ङिपेंङेंसी का प्रयोग कैसे
किया जा सकता है।

<!-- The last line, `[dependencies]`, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
*crates*. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then. -->

अभी *src/main.rs* खोलकर देखें:

<!-- Now open *src/main.rs* and take a look: -->

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

`Cargo` ने आप के लिये एक `Hello, world!` प्रोग्राम बनाया है, ठिक उसी प्रकार का
जैसे हमने Listing १-१ मे लिखा था। अभी तक हमारे पहले वाले प्रोग्राम और `Cargo` के
बनाये गये कोङ मे यह अंतर है की `Cargo` ने कोङ को *src* नामक एक फ़ोल्ङर मे रखा
है, और *Cargo.toml* नामक एक फ़ाईल बनाया है।

<!-- Cargo has generated a Hello, world! program for you, just like the one we wrote
in Listing 1-1! So far, the differences between our previous project and the
project Cargo generates are that Cargo placed the code in the *src* directory,
and we have a *Cargo.toml* configuration file in the top directory. -->

`Cargo` यह मानता है की आपके "सोर्स फ़ाईलें" (source files), यानी वह फ़ाईलें
जिनमे आपने कोङ लिखीं हों, *src* फ़ोल्ङेर मे होंगी। सबसे उपरी फ़ोल्ङर सिर्फ़ उन
फ़ाईलों के लिये है, जिनका आपके कोङ से संबंध ना हो। `Cargo` आपको अपने प्रोग्रामों
को संभालने मे मदद करता है। हर चीज के लिये एक जगह है, और हर चीज़ अपने जगह मे है।

<!-- Cargo expects your source files to live inside the *src* directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place. -->

अगर आपने `Cargo` के बिना कोइ प्रोग्राम लिखना चालू कर दिया, जैसे की हमने हमारे
`Hello, world!` प्रोग्राम के साथ किया था, आप उसको `Cargo` से साथ इस्तेमाल के
लिये बदल सकते हैं। केवल प्रोग्राम के कोङ को *src* फ़ोल्ङर मे ङालें और एक उपयुक्त
*Cargo.toml* फ़ाईल बनयें।

<!-- If you started a project that doesn’t use Cargo, as we did with the Hello,
world! project, you can convert it to a project that does use Cargo. Move the
project code into the *src* directory and create an appropriate *Cargo.toml*
file. -->

### `Cargo` के साथ प्रोग्राम को कंपाइल करके चलाना
<!-- ### Building and Running a Cargo Project -->

चलो देखते हैं की `Cargo` के साथ हमरे `Hello, world!` प्रोग्राम चलाने मे क्या अलग
है! अपने *hello_cargo* फ़ोल्ङर मे से, अपने प्रोग्राम को निम्नलिखित आदेश से कंपाइल करें:

<!-- Now let’s look at what’s different when we build and run the Hello, world!
program with Cargo! From your *hello_cargo* directory, build your project by
entering the following command: -->

```text
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

यह आदेश एक चलाने लायक/निष्पादनिय फ़ाइल (जिनहें हम "एक्सेक्यूतेबल" (executable)
फ़ाइल कहते हैं) *target/debug/hello_cargo* (या विंङोज़ मे
*target\debug\hello_cargo.exe*) बनाता है, आपके वर्तमान फ़ोल्ङर मे नही। आप इस
फ़ाइल को निम्नलिखित आदेश से चला सकते हैं:

<!-- This command creates an executable file in *target/debug/hello_cargo* (or
*target\debug\hello_cargo.exe* on Windows) rather than in your current
directory. You can run the executable with this command: -->

```text
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

सब सही चले, तो `Hello, world!` टर्मिनल मे दिखना चाहिये। जब आप पहली बार `cargo
build` चलाते हैं, तो `Cargo` एक उपरी फ़ोल्ङर मे एक नया फ़ाइल बनाता है:
*Cargo.lock*. यह आपके प्रोग्राम के ङिपेंदेंसीयों के संस्करण संख्या का ध्यान रखता
है। इस प्रोग्राम मे ङेपेंङेंसी नही है, इस लिये फ़ाइल छोटा है। आपको कभी इस फ़ाइल
को खुद से बदलने की ज़रूरत नही पधेगी; `Cargo` यह काम खुद करता है।

<!-- If all goes well, `Hello, world!` should print to the terminal. Running `cargo
build` for the first time also causes Cargo to create a new file at the top
level: *Cargo.lock*. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you. -->

हमने अभी एक प्रोग्राम `cargo build` से बनाया, और उस्के निष्पादनिय फ़ाइल
`./target/debug/hello_cargo` को चलाया, इसके बजाय हम दोनो काम `cargo run` से भी
कर सकते थे:

<!-- We just built a project with `cargo build` and ran it with
`./target/debug/hello_cargo`, but we can also use `cargo run` to compile the
code and then run the resulting executable all in one command: -->

```text
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

ध्यान दें कि इस बार `Cargo` ने हमे संकेत नही दिया की वह `hello_cargo` प्रोग्राम
को कंपाइल कर रहा है। `Cargo` ने यह तै कर लिया की कोई फ़ाइल बदली नही थी, इसिलिये
फिर से कंपाइल करे बिना, उसने सिधा निष्पादनिय फ़ाइल को चला दिया। अगर आपने अपने
फ़ाइलों को बदला होता, तो `Cargo` ने चलाने से पहले फिर से प्रोग्राम को बना दिया
होत, और आप यह देखते:

<!-- Notice that this time we didn’t see output indicating that Cargo was compiling
`hello_cargo`. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output: -->

```text
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

`Cargo` `cargo check` नामक एक सुविधा भी देता है। यह जल्द से सुनिश्चित कर लेता है
की चोङ ठिक है (अर्थर्त कंपाइल होगा) की नहि, पर निष्पदनिय फ़ाइल नही बनाता:

<!-- Cargo also provides a command called `cargo check`. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable: -->

```text
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

आप निष्पादनिय फ़ाइल क्युं नही चाहेंगे? अक्सर `cargo check` `cargo build` से कइ
ज़्यादा तेज़ चलता है, क्युंकी कंपाइल करने के प्रक्रिया मे वह कइ कदम छोङ देता
है। अगर आप अपने काम को बार-बार चेक कर रहे हैं, तो `cargo check` का उपयोग ज्यादा
तेज़ है। रस्ट के कइ प्रोग्रामर, प्रोग्राम लिखते समय `cargo check` बार-बार चलाते
है, यह देखने के लिये की वह कंपाइल हो रहा है की नही। वह `cargo build` तभी चलाते
हैं जब वह प्रोग्राम चलाने को तैयार हैं।

<!-- Why would you not want an executable? Often, `cargo check` is much faster than
`cargo build`, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using `cargo check` will
speed up the process! As such, many Rustaceans run `cargo check` periodically
as they write their program to make sure it compiles. Then they run `cargo
build` when they’re ready to use the executable. -->

चलो याद करते हैं कि अभी तक हमने `Cargo` के बारे मे क्या सिखा है:

<!-- Let’s recap what we’ve learned so far about Cargo: -->

* हम `cargo build` या `cargo check` के साथ कोङ को कंपाइल कर सकते हैं।
* हम `cargo run` के साथ, एक ही कदम मे प्रोग्राम कंपाइल करके चला सकते हैं।
* कंपाइल करने के बाद निश्पादनीय फ़ाइल को कोङ के ही फ़ोल्ङर मे रखने के बिजाय,
  `Cargo` उसे *target/debug* फ़ोल्ङर मे रखता है।

<!-- * We can build a project using `cargo build` or `cargo check`.
* We can build and run a project in one step using `cargo run`.
* Instead of saving the result of the build in the same directory as our code,
  Cargo stores it in the *target/debug* directory. -->

`Cargo` का एक और लभ है, उसके आदेश हर आपरेटिंग सिस्टम (विंङोज़, लिनक्स और मैक
अदि) मे एक ही है। इस लिये, हम अभी आपरेटिंग सिस्टम के हिसाब से अलग अलग अनुदेश नही
देंगे।

<!-- An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows. -->

### "रिलीस" (release)/वितरित के लिये बनाना

<!-- ### Building for Release -->

जब आखिर्कार आप अपने प्रोग्राम को वितरित करने को लिये तैयार हैं, तब आप `cargo
build --release` के साथ कंपाइल कर सकते है। इस वकत निष्पादनीय फ़ाइल
*target/debug* के बिजाय *target/release* मे बनता है। इस्से जो निष्पादनीय फ़ाइल
बनता है, वह ज्यादा तेज़ चलेगा, लेकिन प्रोग्राम कंपाइल होने मे ज़्यादा देर लग
सकती है। इसिलिये प्रोग्राम कंपाइल करने के दो प्रक्रियायें हैं: एक जो प्रोग्राम
लिखते समय जलदी-जलदी से कंपाइल करने के लिये, और एक आखिर मे प्रोग्राम बनाने के
लिये, जो आप अपने ग्राहक/उपयोगकर्ताओं को देंगे, जो बार बार नही कंपाइल होत, लेकिन
ज़रोओरी है की वह तेज़ चले। ध्यान रखें, की आप अगर देफना चाहते हैं आपका की
प्रोग्राम कितना तेज़ चल सकता है, तो आप ज़रूर `cargo build --release` के साथ
बनायें और *target/release* मे रके निष्पादनीय फ़ाइल चलाये। पहले कि तऱा दोनो काम
एक साथ करने के लिये आप `cargo run --release` का उप्योग कर सकते हैं।

<!-- When your project is finally ready for release, you can use `cargo build
--release` to compile it with optimizations. This command will create an
executable in *target/release* instead of *target/debug*. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run `cargo build --release` and benchmark with
the executable in *target/release*. -->

### `Cargo`, एक परंपरा

<!-- ### Cargo as Convention -->

सरल प्रोग्रामों को बनाने मे `Cargo` का कोई खास फ़ायदा नही है, लेकिन जैसे आपके
प्रोग्राम और बदे होते जाते हैं, तो इस्का फ़यदा दिखाइ देने लगेग। बदे प्रोग्राम
जिसमे अनेक "क्रेट" (crate) हैं, उनमे `Cargo` को सब संबालने देन फ़यदेमंद रहेगा।

<!-- With simple projects, Cargo doesn’t provide a lot of value over just using
`rustc`, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build. -->

भले ही `hello_cargo` एक बहुत ही सरल प्रोग्राम है, वह अभी ही ज़्यादतर साधनों का
उप्योग कर रहा है जो आप अपने आगे के रस्ट व्यवसाय मे प्रयोग करेंगे। असल में, किसी
भी मौजूदा रस्ट प्रोग्राम पर काम करने के लिये आप निम्न्लिखित आदेशों क प्रयोग कर,
उसके कोङ को `Git` से दाउंलोङ करके कंपाइल कर सकते हैं:

<!-- Even though the `hello_cargo` project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build: -->

```text
$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
```

`Cargo` पर अधिक जानकारि पाने के लिये निम्न. देखें [उस्का प्रलेखन]:

<!-- For more information about Cargo, check out [its documentation]. -->

[उस्का प्रलेखन]: https://doc.rust-lang.org/cargo/

## सरांश
<!-- ## Summary -->

आप्की अभी रस्ट के रास्ते मे एक महान शुरुआत हो चुकी है। इस अध्याय मे आपने सीखा है की:

<!-- You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to: -->

* `rustup` के ज़रिये रस्ट के सबसे नया संस्करण कैसे इंस्ताल करते हैं
* जब और नया संस्करण आये, तो उसे कैसे पाते हैं
* आपके कंप्यूटर मे रखे गये प्रलेखन को कैसे खोलते हैं
* कैसे एक `Hello, world!` प्रोग्राम को लिखकर `rustc` के साथ चलाते हैं
* कैसे `Cargo` का इस्तेमाल करके एक नया प्रोग्राम बनाके चलाते हैं

<!-- * Install the latest stable version of Rust using `rustup`
* Update to a newer Rust version
* Open locally installed documentation
* Write and run a Hello, world! program using `rustc` directly
* Create and run a new project using the conventions of Cargo -->

समय आ गया है की आप एक थोङा और बदा प्रोग्राम लिखें, जिस से आपको रस्ट कोङ पढने और
लिखने की आदत पधेगी। इसिलिये, अध्याय २ मे, हम एक "अंक अनुमान खेल" (guessing game)
प्रोग्राम बनायेंगे। यदी आप सिधा ही सामन्य प्रोग्रामिंग के अवधारण सिखना चाहते
हैं, तो अध्याय ३ पहले पढकर, अध्याय २ पर लौट सकते हैं।

<!-- This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2. -->
