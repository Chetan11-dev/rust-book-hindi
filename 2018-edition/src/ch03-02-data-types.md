## जानकारी के प्रकार

रस्ट में प्रत्येक जानकारी एक निश्चित *डेटा टाइप* का है, जो रस्ट को बताता है कि उस डेटा/चर के साथ कैसे काम किया जाए। हम दो डेटा टाइप के प्रकार: स्केलर और कंपाउंड को देखेंगे।

ध्यान रखें कि रस्ट कंपाइलर को कंपाइल करते समय, सभी चर का टाइप पता होना चाहिए। कंपाइलर आमतौर पर पता लगा सकता है कि हम कौन्सा टाइप प्रयोग करना चाहते है, यह देखहर कि हम चर का उपयोग कैसे कर रहे हैं। ऐसे मामलों में जब कई टाइप संभव हैं, जैसे जब हमने अध्याय 2 में "गुप्त संख्या की तुलना करें" अनुभाग मे, `parse` का उपयोग करके, एक `String` को एक संख्यात्मक टाइप में परिवर्तित किया, तो हमें  "टाइप एनोटेशन" करके, कंपाइलर को स्पष्ट रूप से टाइप बताना पङा, जैसे:

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```


यदि हम टाइप एनोटेशन यहां नहीं जोड़ते हैं, तो रस्ट निम्नलिखित एरर प्रदर्शित करेगा, जिसका अर्थ है कि कंपाइलर को हमें और अधिक जानकारी देने की आवश्यकता है, जो टाइप हम उपयोग करना चाहते हैं।

```text
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```



आप अन्य डेटा टाइप के लिए अलग टाइप एनोटेशन देखेंगे।


### स्केलर टाइप

*स्केलर* टाइप एक अकेले जानकारी का प्रतिनिधित्व करता है। रस्ट में चार प्राथमिक स्केलर टाइप हैं: पूर्णांक अंक, फ्लोटिंग-पॉइंट संख्या, बूलियन और वर्ण। आप अन्य प्रोग्रामिंग भाषाओं से इन्हें पहचान सकते हैं। आइए जानें कि वे रस्ट में कैसे काम करते हैं।

#### पूर्णांक टाइप

एक *पूर्णांक* एक अंश के बिना एक संख्या है। हमने अध्याय 2 में एक पूर्णांक टाइप का उपयोग किया, `u32` टाइप। यह टाइप घोषणा दर्शाता है कि जो जानकारी इसके साथ जुड़ा हुआ है, वह एक सकारात्मक पूर्णांक संख्या होना चाहिए (ऋणात्मक पूर्णांक टाइप `u` के बजाय `i` से शुरू होता है) जिसमें 32 बिट्स की जगह है। तालिका 3-1, रस्ट के अंतर्निहित पूर्णांक टाइप दिखाता है। सकारात्मक और ऋणात्मक पुर्णांक किए गए कॉलम में प्रत्येक टाइप (उदाहरण के लिए, `i16`) का उपयोग पूर्णांक जानकारी के टाइप को घोषित करने के लिए किया जा सकता है।

<span class="caption">Table 3-1: Integer Types in Rust</span>

| आकार   | सकारात्मक |  ऋणात्मक  |
|--------|---------|----------|
| 8-बिट   | `i8`    | `u8`     |
| 16-बिट  | `i16`   | `u16`    |
| 32-बिट  | `i32`   | `u32`    |
| 64-बिट  | `i64`   | `u64`    |
| 128-बिट | `i128`  | `u128`   |
| चंप्यूटर पर निरभर    | `isize` | `usize`  |

<!-- Translation is terrible. Fix it -->
प्रत्येक संस्करण को सकारात्मक या ऋणात्मक घोशित किया जा सकता है, और इसका एक स्पष्ट आकार होता है। *सकारात्मक* और *ऋणात्मक* का अर्थ है, कि क्या यह संख्या का ऋणात्मक या सकारात्मक होना संभव है - दूसरे शब्दों में, क्या संख्या को इसके साथ एक सकरात्मक्ता का चिंह करने की आवश्यकता है (ऋणात्मक) या क्या यह हमेशा सकारात्मक होगा और इसलिए हो सकता है बिना चिन्ह (बिना संकेत के) के वर्ण किया जा सकता है। यह कागज पर नंबर लिखने जैसे है: जब साइन (सकरात्मक्ता का चिंह) मायने रखता है, तो एक नंबर को प्लस साइन या माइनस साइन के साथ दिखाया जाता है; हालाँकि, जब यह मान लेना सुरक्षित है कि संख्या सकारात्मक है, तो यह बिना किसी संकेत के लिखा जाता है। हस्ताक्षरित संख्या की टूस कांप्लिमेंट मे संग्रहीत की जाती है (यदि आप इसके बारे मे नही जानते, तो आप इसे ऑनलाइन खोज सकते हैं, इसका स्पष्टीकरण इस पुस्तक के दायरे से बाहर है)।

<!-- Too much trouble to translate -->
<!-- प्रत्येक हस्ताक्षर किए गए संस्करण से नंबर स्टोर कर सकते हैं - (2 <sup> n - 1 </ sup>) से 2 <सुप> n - 1 </ sup> - 1 समावेशी, जहां * n * बिट्स की संख्या है जो वेरिएंट का उपयोग करता है। अतः `i8` संख्याओं को स्टोर कर सकता है - (2 <sup> 7 </ sup>) से 2 <सुप> 7 </ sup> - 1, जो कि -128 से 127 के बराबर होता है। अनसाइन्ड वेरिएंट 0 से 2 <सुप तक के नंबर स्टोर कर सकता है। > n </ sup> - 1, इसलिए एक `u8` नंबर को 0 से 2 <सुप> 8 </ sup> - 1 तक संग्रहीत कर सकता है, जो 0 से 255 के बराबर है। -->

`isize` और `usize` टाइप आपके कंप्यूटर के प्रकार पर निर्भर करता है, जिस पर आपका प्रोग्राम चल रहा है: 64 बिट्स यदि आप 64-बिट कंप्यूटर पर हैं और 32 बिट्स यदि आप 32-बिट कंप्यूटर पर हैं।

आप पूर्णांक शाब्दिक तालिका 3-2 में दिखाए गए किसी भी रूप में लिख सकते हैं। ध्यान दें कि बाइट लिटरल को छोड़कर सभी संख्या लिटरल एक टाइप प्रत्यय, जैसे `57u8`, और `_` एक दृश्य विभाजक, जैसे `1_000` की अनुमति देते हैं।

<span class="caption">Table 3-2: Integer Literals in Rust</span>

| अंक लिटरल | उदाहरण |
| ------------------ | --------------- |
| दशमलव | `98_222`  |
| हेक्स | `0xff` |
| आंक्टल | `0o77` |
| बाइनरी | `0b1111_0000` |
| बाइट (केवल `u8`) | `b'A'` |

तो आपको कैसे पता चलेगा कि पूर्णांक का कौन सा टाइप उपयोग करना है? यदि आप अनिश्चित हैं, तो रस्ट के डिफॉल्ट आमतौर पर अच्छे विकल्प होते हैं, और पूर्णांक के लिए डिफ़ॉल्ट टाइप `i32` है: यह टाइप आमतौर पर सबसे तेज़ है, 64-बिट सिस्टम पर भी। प्राथमिक स्थिति जिसमें आप `isize` या `usize` का उपयोग करते हैं, जब किसी प्रकार के संग्रह को अनुक्रमित किया जा रहा हो।

##### पूर्णांक अतिप्रवाह

मान लें कि आपके पास एक `u8` चर है, जो शून्य और `255` के बीच जानकारी रख सकता है। यदि आप इसे `256` में बदलने का प्रयास करते हैं तो क्या होता है? इसे "पूर्णांक अतिप्रवाह" कहा जाता है, और रस्ट में इस व्यवहार के आसपास कुछ दिलचस्प नियम हैं। डीबग मोड में संकलन करते समय, रस्ट इस तरह के मुद्दे की जाँच करता है और आपके प्रोग्राम मे *आतंक* का कारण बनेगा। रस्ट आतंक/पैनिक शब्द का उपयोग करता है जब एक प्रोग्राम एक एरर के साथ बाहर निकलता है। हम इसकी अध्याय 9 में अधिक चर्चा करेंगे।

रिलीज़ बिल्ड में, रस्ट अतिप्रवाह के लिए जाँच नहीं करता है, और इसके बजाय "टूस कांप्लिमेंट रैपिंग" नामक कुछ करेगा। संक्षेप में, `256` `0`,  और `257` `1` बन जाता है, और अतिप्रवाह पर निरभर करना एक एरर माना जाता है, भले ही यह व्यवहार चाहते हो। यदि आप यह व्यवहार स्पष्ट रूप से चाहते हैं, तो स्टैंङर्ङ लाइब्रेरी में एक टाइप, `Wrapping` है, जो इसे स्पष्ट रूप से प्रदान करता है।

#### फ्लोटिंग-पॉइंट टाइप

रस्ट में *फ़्लोटिंग-पॉइंट संक्या* के लिए दो आदिम टाइप हैं, जो दशमलव अंश के साथ संख्या हैं। रस्ट का फ़्लोटिंग-पॉइंट टाइप `f32` और `f64` हैं, जो क्रमशः 32 बिट्स और 64 बिट्स के हैं। डिफ़ॉल्ट टाइप, `f64` है क्योंकि आधुनिक CPU पर यह गति मे `f32` से लगभग समान के समान है, लेकिन अधिक परिशुद्धता के सक्षम है।

यहां एक उदाहरण है जो फ्लोटिंग-पॉइंट संख्या को कार्रवाई में दिखाता है:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```



फ्लोटिंग-पॉइंट नंबर IEEE-754 मानक के अनुसार दर्शाए गए हैं। `f32` टाइप एक एकल-सटीक फ़्लोट है, और `f64` में दोहरी सटीकता फ़्लोट है।

#### न्यूमेरिक ऑपरेशन

रस्ट उन सभी मूल गणितीय क्रियाओं का समर्थन करता है जिनकी आप संख्या टाइप के लिए अपेक्षा रखते हैं: जोङ, घटाव, गुणा, भाग और शेष। निम्न कोङ दिखाता है कि आप `let` वाक्य में प्रत्येक का उपयोग कैसे करते हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
```

इन वाक्यों में प्रत्येक एक्सप्रेशन एक गणितीय ऑपरेटर का उपयोग करता है और एक जानकारी का मूल्यांकन करता है, जो फिर चर से बंधे जाते है। परिशिष्ट B में उन सभी ऑपरेटरों की सूची है जो रस्ट प्रदान करता है।

#### बूलियन टाइप

जैसा कि अधिकांश अन्य प्रोग्रामिंग भाषाओं में, रस्ट में एक 'बूलियन' टाइप है जिसके दो संभव मूल्य: `true` (सही) और `false` (गलत) हो सकते हैं। बूलियन टाइप रस्ट में `bool` का उपयोग करके निर्दिष्ट किया गया है। उदाहरण के लिए:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
```

<!--- Hand-Corrected till here --->

बूलियन जानकारी का उपभोग करने का मुख्य तरीका सशर्त है, जैसे कि `if` _EXPRESSION_। हम "कंट्रोल फ़्लो" अनुभाग में _ROLDER_81 _EXPRESSIONS_ रस्ट में कैसे काम करते हैं, इसे कवर करेंगे।

बूलियन आकार में एक बाइट होते हैं।

_HOLDER_12

चरित्र टाइप

अब तक हमने केवल संख्याओं के साथ काम किया है, लेकिन रस्ट अक्षरों का भी समर्थन करता है। रस्ट का `char` _TYPE_ भाषा का सबसे प्रमुख अक्षर है टाइप, और निम्न कोङ इसका उपयोग करने का एक तरीका दिखाता है। (ध्यान दें कि `char` शाब्दिक एकल उद्धरण के साथ निर्दिष्ट है, जैसा कि स्ट्रिंग शाब्दिक के विपरीत है, जो दोहरे उद्धरण चिह्नों का उपयोग करते हैं।)

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```



रस्ट का `char` _TYPE_ एक यूनिकोड स्केलर जानकारी का प्रतिनिधित्व करता है, जिसका अर्थ है कि यह सिर्फ ASCII से बहुत अधिक प्रतिनिधित्व कर सकता है। उच्चारण किए गए पत्र; चीनी, जापानी और कोरियाई वर्ण; इमोजी; और शून्य-चौड़ाई रिक्त स्थान सभी वैध `char` _VALUES_ में रस्ट हैं। यूनिकोड स्केलर जानकारी की सीमा `U+0000` से `U+D7FF` और `U+E000` से `U+10FFFF` तक सम्मिलित है। हालाँकि, यूनिकोड में एक "चरित्र" वास्तव में एक अवधारणा नहीं है, इसलिए "चरित्र" जो एक `char` _RUST_ में क्या है, के साथ मेल नहीं खा सकता है के लिए आपका मानव अंतर्ज्ञान है। हम इस विषय पर अध्याय 8 में "स्ट्रिंग" पर विस्तार से चर्चा करेंगे।

_HOLDER_14

यौगिक टाइप

* यौगिक टाइप * एकाधिक जानकारी को एक टाइप में समूहित कर सकता है। रस्ट में दो आदिम यौगिक हैं टाइप: ट्यूपल्स और सरणियाँ।

_HOLDER_15

टपल टाइप

एक ट्यूल एक सामान्य तरीका है जो कुछ अन्य जानकारी की संख्या को एक यौगिक टाइप में टाइप की विविधता के साथ जोड़ देता है। टुपल्स की एक निश्चित लंबाई होती है: एक बार घोषित होने के बाद, वे आकार में बढ़ या सिकुड़ नहीं सकते हैं।

हम कोष्ठकों के अंदर जानकारी की अल्पविराम-अलग सूची लिखकर एक टपल बनाते हैं। टपल में प्रत्येक स्थिति में एक टाइप है, और tuple में विभिन्न जानकारी के टाइप को समान नहीं होना है। हमने इस उदाहरण में वैकल्पिक टाइप एनोटेशन जोड़े हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```



चर _HOLDER_91 पूरे टूपल को बांधता है, क्योंकि एक ट्यूपल को एक एकल यौगिक तत्व माना जाता है। व्यक्तिगत जानकारी को एक ट्यूपल से बाहर निकालने के लिए, हम इस तरह से एक tuple जानकारी को नष्ट करने के लिए मिलान पैटर्न का उपयोग कर सकते हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```



यह प्रोग्राम पहले एक ट्यूपल बनाता है और इसे _VARIABLE__HOLDER_92 से बांधता है। यह तब `tup` के साथ `tup` को लेने और इसे तीन अलग-अलग चर, `x`, `y`, और `z` में बदलने के लिए एक पैटर्न का उपयोग करता है। इसे * विनाशकारी * कहा जाता है, क्योंकि यह एकल टपल को तीन भागों में तोड़ता है। अंत में, प्रोग्राम _HOLDER_98 के जानकारी को प्रिंट करता है, जो कि `6.4` है।

पैटर्न मिलान के माध्यम से विनाशकारी के अलावा, हम एक अवधि (`.`) का उपयोग करके सीधे एक tuple तत्व का उपयोग कर सकते हैं, उसके बाद जानकारी के सूचकांक तक हम पहुंचना चाहते हैं। उदाहरण के लिए:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```



यह प्रोग्राम एक tuple बनाता है, `x`, और फिर उनके सूचकांक का उपयोग करके प्रत्येक तत्व के लिए नया चर बनाता है। अधिकांश प्रोग्रामिंग भाषाओं के साथ, टुपल में पहला इंडेक्स 0 है।

_HOLDER_19

एरे टाइप

एकाधिक जानकारी का संग्रह करने का एक अन्य तरीका * सरणी * के साथ है। टपल के विपरीत, सरणी के प्रत्येक तत्व में समान टाइप होना चाहिए। रस्ट में सरणियाँ कुछ अन्य भाषाओं में सरणियों से भिन्न होती हैं क्योंकि रस्ट में सरणियाँ एक निश्चित लंबाई होती हैं, जैसे ट्यूपल्स।

रस्ट में, सरणी में जा रहे जानकारी को वर्ग कोष्ठक के अंदर अल्पविराम से अलग सूची के रूप में लिखा गया है:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```



Arrays तब उपयोगी होती है जब आप चाहते हैं कि ढेर के बजाय आपका डेटा स्टैक पर आबंटित हो (हम स्टैक और हीप को अध्याय 4 में अधिक चर्चा करेंगे), या जब आप यह सुनिश्चित करना चाहते हैं कि आपके पास हमेशा तत्वों की एक निश्चित संख्या हो। एक सरणी हालांकि वेक्टर टाइप के रूप में लचीली नहीं है, हालांकि। एक वेक्टर एक समान संग्रह है टाइप मानक पुस्तकालय द्वारा प्रदान किया गया है जो * आकार में बढ़ने या सिकुड़ने की अनुमति है। यदि आप किसी सरणी या वेक्टर का उपयोग करने के लिए अनिश्चित हैं, तो आपको संभवतः वेक्टर का उपयोग करना चाहिए। अध्याय 8 अधिक विस्तार से वैक्टर पर चर्चा करता है।

जब आप वेक्टर के बजाय एक सरणी का उपयोग करना चाहते हैं, तो इसका एक उदाहरण प्रोग्राम में है, जिसे वर्ष के महीनों के नाम जानने की आवश्यकता है। यह बहुत कम संभावना नहीं है कि इस तरह के प्रोग्राम को महीनों को जोड़ने या निकालने की आवश्यकता होगी, इसलिए आप एक सरणी का उपयोग कर सकते हैं क्योंकि आप जानते हैं कि इसमें हमेशा 12 आइटम होंगे:

```rust
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```



Arrays में एक दिलचस्प टाइप है; यह इस तरह दिखता है: `[type; number]`। उदाहरण के लिए:

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```



सबसे पहले, वहाँ वर्ग कोष्ठक हैं; वे एक सरणी बनाने के लिए वाक्यविन्यास की तरह दिखते हैं। अंदर, सूचना के दो टुकड़े हैं, एक अर्धविराम द्वारा अलग किया गया है। सरणी के प्रत्येक तत्व का पहला टाइप है। चूंकि सभी तत्वों में समान टाइप है, इसलिए हमें केवल इसे एक बार सूचीबद्ध करना होगा। अर्धविराम के बाद, एक संख्या है जो सरणी की लंबाई को इंगित करती है। चूंकि किसी सरणी का एक निश्चित आकार होता है, यह संख्या हमेशा समान होती है, भले ही सरणी के तत्वों को संशोधित किया गया हो, यह बढ़ या सिकुड़ नहीं सकता है।

_HOLDER_23

ऐरे तत्वों तक पहुँचना

एक सरणी स्टैक पर आवंटित स्मृति का एक एकल हिस्सा है। आप अनुक्रमणिका का उपयोग करके किसी सरणी के तत्वों को इस तरह एक्सेस कर सकते हैं:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```



इस उदाहरण में, `first` नाम के चर को _VALUE__HOLDER_104 मिलेगा, क्योंकि यह सरणी में सूचकांक `[0]` पर जानकारी _HOLDER_106 नाम के चर को सरणी में सूचकांक `[1]` से जानकारी _HOLDER_107 मिलेगा।

_HOLDER_25

अमान्य एरे तत्व अभिगमन

यदि आप किसी ऐसे सरणी के तत्व को एक्सेस करने का प्रयास करते हैं, जो सरणी के अंत में स्थित है? उदाहरण के लिए, आप निम्न कोङ के लिए उदाहरण बदलते हैं, जो कंपाइल होगा, लेकिन जब आप चलते हैं तो एक एरर से बाहर निकलें:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```



इस कोङ को चलाने से `cargo run` का उपयोग करके निम्नलिखित परिणाम प्राप्त होता है:

```text
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```



संकलन किसी भी एरर का उत्पादन नहीं करता है, लेकिन प्रोग्राम के परिणामस्वरूप * रनटाइम * एरर हुआ और सफलतापूर्वक बाहर नहीं निकला। जब आप अनुक्रमणिका का उपयोग करके किसी तत्व तक पहुंचने का प्रयास करते हैं, तो रस्ट यह जाँच करेगा कि आपके द्वारा निर्दिष्ट सूचकांक सरणी लंबाई से कम है। यदि सूचकांक लंबाई से अधिक है, तो रस्ट घबराएगा।

यह कार्रवाई में रस्ट के सुरक्षा सिद्धांतों का पहला उदाहरण है। कई निम्न-स्तरीय भाषाओं में, इस तरह की जाँच नहीं की जाती है, और जब आप एक गलत इंडेक्स प्रदान करते हैं, तो अमान्य मेमोरी तक पहुँचा जा सकता है। रस्ट आपको मेमोरी एक्सेस और जारी रखने की अनुमति देने के बजाय तुरंत बाहर निकलने से एरर के इस प्रकार से बचाता है। अध्याय 9 में रस्ट के एरर
